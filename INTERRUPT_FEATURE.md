# 打断功能说明

## 🛑 功能概述

J.A.R.V.I.S 现在支持在AI回复或工具执行期间打断操作，让你可以随时中止不需要的操作。

## ⚙️ 配置

在 `config/config.go` 中配置：

```go
// 打断配置
InterruptKey = "n"         // 打断AI回复的按键
EnableInterrupt = true     // 是否启用打断功能

// 历史记录配置
MaxHistoryRounds = 60      // 最多加载的历史对话轮数（0表示全部加载）
```

## 📝 使用方法

### 1. 打断AI回复

当AI正在流式输出回复时：

```
◆ JARVIS >> 我来详细解释一下这个复杂的算法...

[提示] 输入 'n' 并回车可打断当前操作
```

如果你不想等AI说完，直接输入 `n` 并回车：

```
n ↵

[打断] 操作已中止
[✗] 操作已被打断
```

### 2. 打断工具执行

当工具正在执行时：

```
  ┌────────────────────────────────────────────────────────┐
  │ 工具调用: search_code                                    │
  │ / 执行中...

[提示] 输入 'n' 并回车可打断当前操作
```

输入 `n` 并回车即可中止：

```
n ↵

[打断] 操作已中止
[✗] 工具调用已被打断
```

工具执行被打断后，结果会被标记为 `[✗] 工具执行已被打断`

## 🎯 使用场景

### 何时使用打断？

1. **AI回复过长**：AI开始长篇大论，而你只想要简短答案
2. **工具执行错误**：发现工具调用的参数有误，想立即停止
3. **改变主意**：突然想换个思路，不想等当前操作完成
4. **性能问题**：工具执行时间过长（如大范围搜索）

### 示例场景

#### 场景1：AI回复太啰嗦

```
▶ USER >> 解释什么是递归

◆ JARVIS >> 递归是一个函数调用自身的编程技术。让我从历史说起...
递归的概念最早可以追溯到19世纪的数学家...（开始长篇大论）

[提示] 输入 'n' 并回车可打断当前操作
n ↵

[打断] 操作已中止
[✗] 操作已被打断

────────────────────────────────────────────────────────────

▶ USER >> 用一句话解释递归

◆ JARVIS >> 递归就是函数调用自身来解决问题，通常用于处理树状或嵌套结构。
```

#### 场景2：工具参数错误

```
▶ USER >> 在整个项目中搜索"test"

◆ JARVIS >> 收到，开始全局搜索。

  ┌────────────────────────────────────────────────────────┐
  │ 工具调用: search_code                                    │
  │ / 执行中...

（发现会搜索很久，想改成只搜索特定目录）

n ↵

[打断] 操作已中止
[✗] 工具调用已被打断

────────────────────────────────────────────────────────────

▶ USER >> 只在 internal/ 目录下搜索"test"
```

## ⚙️ 技术细节

### 实现原理

1. **监听器创建**：每次用户输入后，创建一个打断监听器
2. **后台监听**：在goroutine中监听标准输入
3. **状态检查**：AI回复和工具执行过程中定期检查打断状态
4. **优雅退出**：检测到打断后，立即停止当前操作并跳转到清理代码

### 代码结构

```
internal/keyboard/interrupt.go  - 打断监听器实现
config/config.go                - 打断配置
main.go                         - 集成打断逻辑
```

### 关键代码

```go
// 创建监听器
interruptMonitor := keyboard.NewInterruptMonitor(config.InterruptKey)
interruptMonitor.Start()

// 检查打断
if interruptMonitor != nil && interruptMonitor.IsInterrupted() {
    fmt.Println("\n[✗] 操作已被打断")
    goto interrupted
}

// 清理
interrupted:
    if interruptMonitor != nil {
        interruptMonitor.Stop()
    }
```

## 🔧 自定义配置

### 更改打断键

修改 `config/config.go`：

```go
InterruptKey = "x"  // 改用 'x' 键打断
```

### 禁用打断功能

```go
EnableInterrupt = false  // 关闭打断功能
```

### 调整历史记录数量

```go
MaxHistoryRounds = 30   // 只加载最近30轮对话
MaxHistoryRounds = 0    // 加载全部历史记录
```

## 📊 历史记录限制

### 为什么限制历史记录？

1. **减少token消耗**：避免每次都发送大量历史消息给API
2. **提高响应速度**：更少的上下文意味着更快的处理速度
3. **聚焦当前任务**：只保留最近的对话，避免无关上下文干扰

### 轮数计算规则

一轮对话包括：
- 1条用户消息 (user)
- 1条AI回复 (assistant)
- 0-N条工具调用结果 (tool)

示例：
```
MaxHistoryRounds = 60

加载策略：
- 系统提示词（system）：始终保留
- 最近60轮用户对话：保留
- 超过60轮的旧对话：自动丢弃
```

### 历史文件说明

- **chat_history.json**：完整的历史记录会被保存
- **加载时过滤**：只有加载时才限制轮数，保存时仍然保存全部
- **好处**：可以随时修改 `MaxHistoryRounds` 来调整加载的历史数量

## 💡 最佳实践

1. **打断键设置**：
   - 选择不常用的单个字母（如 `n`, `x`）
   - 避免使用 `y`, `a` 等可能在批准流程中用到的键

2. **历史记录配置**：
   - **编程任务**：建议 30-60 轮（保留足够上下文）
   - **简单问答**：可以设置更少（10-20 轮）
   - **长期项目**：如果内存和token不是问题，可以设为 0（全部加载）

3. **打断时机**：
   - AI回复开始后立即打断：如果意识到问题描述有误
   - 工具执行开始后打断：如果发现参数错误
   - 避免频繁打断：可能导致对话历史混乱

## 🐛 注意事项

1. **输入缓冲**：打断键需要按回车才生效（不是实时按键）
2. **工具执行**：某些工具（如文件写入）可能在打断前已经执行完成
3. **历史记录**：被打断的操作仍会记录在历史中，但标记为已打断
4. **Windows兼容**：目前使用标准输入监听，跨平台兼容

## 🚀 未来改进

- [ ] 支持实时按键检测（无需回车）
- [ ] 支持多个打断键组合
- [ ] 打断后提供"继续"选项
- [ ] 工具执行打断的更细粒度控制
- [ ] 打断统计和分析

---

**J.A.R.V.I.S** - 现在更加智能和可控！
