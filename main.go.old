package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/sashabaranov/go-openai"
)

// ==================== é…ç½® ====================

const (
	APIKey      = "sk-bd6e9d3071924a7c8000a26727d2a5e1"
	BaseURL     = "https://api.deepseek.com/v1"
	Model       = "deepseek-chat"
	HistoryFile = "chat_history.json"
)

// ==================== æ•°æ®ç»“æ„ ====================

type Message struct {
	Role       string            `json:"role"`
	Content    string            `json:"content,omitempty"`
	ToolCalls  []openai.ToolCall `json:"tool_calls,omitempty"`
	ToolCallID string            `json:"tool_call_id,omitempty"`
}

type ProcessInfo struct {
	ID       string
	Cmd      *exec.Cmd
	Stdin    io.WriteCloser
	Output   []string
	Mutex    sync.Mutex
	Done     bool
	ExitCode int
}

type ProcessManager struct {
	processes map[string]*ProcessInfo
	mutex     sync.Mutex
	counter   int
}

// æ“ä½œå¤‡ä»½ï¼ˆç”¨äºæ’¤é”€ï¼‰
type OperationBackup struct {
	ToolCallID string
	Type       string // edit, rename, delete
	FilePath   string
	OldContent []byte
	EditCount  int // å¯¹åŒä¸€æ–‡ä»¶çš„ä¿®æ”¹æ¬¡æ•°
}

var backups []OperationBackup
var backupMutex sync.Mutex

// ==================== è¿›ç¨‹ç®¡ç†å™¨ ====================

func NewProcessManager() *ProcessManager {
	return &ProcessManager{
		processes: make(map[string]*ProcessInfo),
	}
}

func (pm *ProcessManager) StartProcess(command string) (string, error) {
	pm.mutex.Lock()
	pm.counter++
	processID := fmt.Sprintf("%d", time.Now().Unix()*1000+int64(pm.counter))
	pm.mutex.Unlock()

	cmd := exec.Command("bash", "-c", command)

	stdin, err := cmd.StdinPipe()
	if err != nil {
		return "", err
	}

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return "", err
	}

	stderr, err := cmd.StderrPipe()
	if err != nil {
		return "", err
	}

	process := &ProcessInfo{
		ID:     processID,
		Cmd:    cmd,
		Stdin:  stdin,
		Output: []string{},
	}

	pm.mutex.Lock()
	pm.processes[processID] = process
	pm.mutex.Unlock()

	if err := cmd.Start(); err != nil {
		return "", err
	}

	go pm.collectOutput(process, stdout, stderr)

	go func() {
		cmd.Wait()
		process.Mutex.Lock()
		process.Done = true
		if cmd.ProcessState != nil {
			process.ExitCode = cmd.ProcessState.ExitCode()
		}
		process.Mutex.Unlock()
	}()

	return processID, nil
}

func (pm *ProcessManager) collectOutput(process *ProcessInfo, stdout, stderr io.ReadCloser) {
	scanner := bufio.NewScanner(io.MultiReader(stdout, stderr))
	for scanner.Scan() {
		line := scanner.Text()
		process.Mutex.Lock()
		process.Output = append(process.Output, line)
		if len(process.Output) > 1000 {
			process.Output = process.Output[len(process.Output)-1000:]
		}
		process.Mutex.Unlock()
	}
}

func (pm *ProcessManager) SendInput(processID, input string) error {
	pm.mutex.Lock()
	process, exists := pm.processes[processID]
	pm.mutex.Unlock()

	if !exists {
		return fmt.Errorf("è¿›ç¨‹ä¸å­˜åœ¨: %s", processID)
	}

	process.Mutex.Lock()
	defer process.Mutex.Unlock()

	if process.Done {
		return fmt.Errorf("è¿›ç¨‹å·²ç»“æŸ")
	}

	_, err := process.Stdin.Write([]byte(input))
	return err
}

func (pm *ProcessManager) GetOutput(processID string) (string, string, error) {
	pm.mutex.Lock()
	process, exists := pm.processes[processID]
	pm.mutex.Unlock()

	if !exists {
		return "", "", fmt.Errorf("è¿›ç¨‹ä¸å­˜åœ¨: %s", processID)
	}

	process.Mutex.Lock()
	defer process.Mutex.Unlock()

	output := strings.Join(process.Output, "\n")
	process.Output = []string{}

	var status string
	if process.Done {
		status = fmt.Sprintf("å·²é€€å‡º(code=%d)", process.ExitCode)
	} else {
		status = "è¿è¡Œä¸­"
	}

	return output, status, nil
}

func (pm *ProcessManager) KillProcess(processID string) error {
	pm.mutex.Lock()
	process, exists := pm.processes[processID]
	pm.mutex.Unlock()

	if !exists {
		return fmt.Errorf("è¿›ç¨‹ä¸å­˜åœ¨: %s", processID)
	}

	if process.Cmd.Process != nil {
		return process.Cmd.Process.Kill()
	}
	return nil
}

var processManager = NewProcessManager()

// ==================== å·¥å…·å®šä¹‰ ====================

func getTools() []openai.Tool {
	return []openai.Tool{
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "read_file",
				Description: "è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€ç”¨æˆ·æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„",
						},
					},
					"required": []string{"file"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "edit_file",
				Description: "ç²¾å‡†ç¼–è¾‘æ–‡ä»¶ï¼Œæ›¿æ¢oldä¸ºnewï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼Œå¯æ’¤é”€ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„",
						},
						"old": map[string]interface{}{
							"type":        "string",
							"description": "è¦æ›¿æ¢çš„å†…å®¹ï¼ˆå¿…é¡»å”¯ä¸€åŒ¹é…ï¼‰",
						},
						"new": map[string]interface{}{
							"type":        "string",
							"description": "æ–°å†…å®¹",
						},
					},
					"required": []string{"file", "old", "new"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "rename_symbol",
				Description: "æ™ºèƒ½é‡å‘½åç¬¦å·ï¼ŒGoæ–‡ä»¶ç”¨ASTï¼Œå…¶ä»–æ–‡ä»¶ç”¨æ­£åˆ™ï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼Œå¯æ’¤é”€ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„",
						},
						"old_symbol": map[string]interface{}{
							"type":        "string",
							"description": "æ—§ç¬¦å·å",
						},
						"new_symbol": map[string]interface{}{
							"type":        "string",
							"description": "æ–°ç¬¦å·å",
						},
					},
					"required": []string{"file", "old_symbol", "new_symbol"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "delete_file",
				Description: "åˆ é™¤æ–‡ä»¶ï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼Œå¯æ’¤é”€ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„",
						},
					},
					"required": []string{"file"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "run_command",
				Description: "æ‰§è¡Œå‘½ä»¤ï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼Œä¸å¯æ’¤é”€ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"command": map[string]interface{}{
							"type":        "string",
							"description": "è¦æ‰§è¡Œçš„å‘½ä»¤",
						},
						"interactive": map[string]interface{}{
							"type":        "boolean",
							"description": "æ˜¯å¦äº¤äº’å¼è¿è¡Œ",
						},
					},
					"required": []string{"command", "interactive"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "send_input",
				Description: "å‘äº¤äº’å¼è¿›ç¨‹å‘é€è¾“å…¥ï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"process_id": map[string]interface{}{
							"type":        "string",
							"description": "è¿›ç¨‹ID",
						},
						"input": map[string]interface{}{
							"type":        "string",
							"description": "è¾“å…¥å†…å®¹",
						},
					},
					"required": []string{"process_id", "input"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "get_output",
				Description: "æŸ¥çœ‹è¿›ç¨‹è¾“å‡ºï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€ç”¨æˆ·æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"process_id": map[string]interface{}{
							"type":        "string",
							"description": "è¿›ç¨‹ID",
						},
					},
					"required": []string{"process_id"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "kill_process",
				Description: "ç»ˆæ­¢è¿›ç¨‹ï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"process_id": map[string]interface{}{
							"type":        "string",
							"description": "è¿›ç¨‹ID",
						},
					},
					"required": []string{"process_id"},
				},
			},
		},
		// ==================== ä»£ç æœç´¢å·¥å…· ====================
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "search_code",
				Description: "åœ¨é¡¹ç›®ä¸­æœç´¢ä»£ç ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"query": map[string]interface{}{
							"type":        "string",
							"description": "æœç´¢å†…å®¹",
						},
						"path": map[string]interface{}{
							"type":        "string",
							"description": "æœç´¢è·¯å¾„ï¼Œé»˜è®¤å½“å‰ç›®å½•",
						},
						"file_pattern": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è¿‡æ»¤ï¼Œå¦‚ *.go",
						},
						"is_regex": map[string]interface{}{
							"type":        "boolean",
							"description": "æ˜¯å¦ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼",
						},
					},
					"required": []string{"query"},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "find_symbol",
				Description: "æŸ¥æ‰¾å‡½æ•°ã€ç±»å‹ã€å˜é‡çš„å®šä¹‰ä½ç½®ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"symbol": map[string]interface{}{
							"type":        "string",
							"description": "ç¬¦å·åç§°",
						},
						"symbol_type": map[string]interface{}{
							"type":        "string",
							"description": "ç¬¦å·ç±»å‹ï¼šfunction, type, var, constï¼ˆå¯é€‰ï¼‰",
						},
					},
					"required": []string{"symbol"},
				},
			},
		},
		// ==================== é¡¹ç›®åˆ†æå·¥å…· ====================
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "list_directory",
				Description: "åˆ—å‡ºç›®å½•ä¸‹çš„æ–‡ä»¶å’Œå­ç›®å½•ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"path": map[string]interface{}{
							"type":        "string",
							"description": "ç›®å½•è·¯å¾„ï¼Œé»˜è®¤å½“å‰ç›®å½•",
						},
						"recursive": map[string]interface{}{
							"type":        "boolean",
							"description": "æ˜¯å¦é€’å½’åˆ—å‡ºå­ç›®å½•",
						},
						"pattern": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è¿‡æ»¤ï¼Œå¦‚ *.go",
						},
					},
					"required": []string{},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "get_project_structure",
				Description: "è·å–é¡¹ç›®ç›®å½•æ ‘ç»“æ„ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"max_depth": map[string]interface{}{
							"type":        "integer",
							"description": "æœ€å¤§æ·±åº¦ï¼Œé»˜è®¤3",
						},
					},
					"required": []string{},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "get_file_stats",
				Description: "è·å–æ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯ï¼ˆè¡Œæ•°ã€å¤§å°ç­‰ï¼‰ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„",
						},
					},
					"required": []string{"file"},
				},
			},
		},
		// ==================== Gitå·¥å…· ====================
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "git_status",
				Description: "æŸ¥çœ‹Gitä»“åº“çŠ¶æ€ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type":       "object",
					"properties": map[string]interface{}{},
					"required":   []string{},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "git_diff",
				Description: "æŸ¥çœ‹æ–‡ä»¶ä¿®æ”¹å·®å¼‚ï¼ˆæŸ¥è¯¢æ“ä½œï¼Œæ— éœ€æ‰¹å‡†ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"file": map[string]interface{}{
							"type":        "string",
							"description": "æ–‡ä»¶è·¯å¾„ï¼Œä¸æŒ‡å®šåˆ™æ˜¾ç¤ºæ‰€æœ‰",
						},
					},
					"required": []string{},
				},
			},
		},
		{
			Type: openai.ToolTypeFunction,
			Function: &openai.FunctionDefinition{
				Name:        "git_commit",
				Description: "æäº¤æ›´æ”¹åˆ°Gitï¼ˆéœ€ç”¨æˆ·æ‰¹å‡†ï¼Œä¸å¯æ’¤é”€ï¼‰",
				Parameters: map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"message": map[string]interface{}{
							"type":        "string",
							"description": "æäº¤ä¿¡æ¯",
						},
						"files": map[string]interface{}{
							"type":        "array",
							"items":       map[string]interface{}{"type": "string"},
							"description": "è¦æäº¤çš„æ–‡ä»¶åˆ—è¡¨",
						},
					},
					"required": []string{"message"},
				},
			},
		},
	}
}

// ==================== å·¥å…·æ‰§è¡Œ ====================

func executeReadFile(args map[string]interface{}) string {
	file := args["file"].(string)
	content, err := os.ReadFile(file)
	if err != nil {
		return fmt.Sprintf("âŒ è¯»å–å¤±è´¥: %v", err)
	}
	return fmt.Sprintf("ğŸ“„ æ–‡ä»¶å†…å®¹:\n```\n%s```", string(content))
}

func executeEditFile(toolCallID string, args map[string]interface{}) string {
	file := args["file"].(string)
	old := args["old"].(string)
	new := args["new"].(string)

	// è¯»å–åŸå†…å®¹ï¼ˆç”¨äºå¤‡ä»½ï¼‰
	oldContent, err := os.ReadFile(file)
	if err != nil {
		return fmt.Sprintf("âŒ è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
	}

	text := string(oldContent)
	count := strings.Count(text, old)

	if count == 0 {
		return "âŒ æœªæ‰¾åˆ°è¦æ›¿æ¢çš„å†…å®¹"
	}
	if count > 1 {
		return fmt.Sprintf("âŒ æ‰¾åˆ°%då¤„åŒ¹é…ï¼Œæ— æ³•ç¡®å®šå”¯ä¸€ä½ç½®", count)
	}

	// æ‰§è¡Œæ›¿æ¢
	newText := strings.Replace(text, old, new, 1)
	if err := os.WriteFile(file, []byte(newText), 0644); err != nil {
		return fmt.Sprintf("âŒ å†™å…¥å¤±è´¥: %v", err)
	}

	// ä¿å­˜å¤‡ä»½ï¼ˆåŒä¸€æ–‡ä»¶åªä¿ç•™ç¬¬ä¸€æ¬¡å¤‡ä»½ï¼‰
	backupMutex.Lock()
	// æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯¥æ–‡ä»¶çš„å¤‡ä»½
	hasBackup := false
	for _, b := range backups {
		if b.FilePath == file {
			hasBackup = true
			break
		}
	}
	// åªåœ¨ç¬¬ä¸€æ¬¡ä¿®æ”¹æ—¶ä¿å­˜å¤‡ä»½
	if !hasBackup {
		backups = append(backups, OperationBackup{
			ToolCallID: toolCallID,
			Type:       "edit",
			FilePath:   file,
			OldContent: oldContent,
			EditCount:  1,
		})
	} else {
		// å¢åŠ ä¿®æ”¹æ¬¡æ•°
		for i := range backups {
			if backups[i].FilePath == file {
				backups[i].EditCount++
				break
			}
		}
	}
	backupMutex.Unlock()

	return fmt.Sprintf("âœ… æ–‡ä»¶å·²ä¿®æ”¹: %sï¼ˆç­‰å¾…ç”¨æˆ·æ‰¹å‡†ï¼‰", file)
}

func executeRenameSymbol(toolCallID string, args map[string]interface{}) string {
	file := args["file"].(string)
	oldSymbol := args["old_symbol"].(string)
	newSymbol := args["new_symbol"].(string)

	// å¤‡ä»½åŸæ–‡ä»¶
	oldContent, err := os.ReadFile(file)
	if err != nil {
		return fmt.Sprintf("âŒ è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
	}

	var result string
	var newContent []byte

	if strings.HasSuffix(file, ".go") {
		// Goæ–‡ä»¶ç”¨AST
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
		if err != nil {
			return fmt.Sprintf("âŒ è§£æGoæ–‡ä»¶å¤±è´¥: %v", err)
		}

		changeCount := 0
		ast.Inspect(node, func(n ast.Node) bool {
			if ident, ok := n.(*ast.Ident); ok {
				if ident.Name == oldSymbol {
					ident.Name = newSymbol
					changeCount++
				}
			}
			return true
		})

		if changeCount == 0 {
			return fmt.Sprintf("âŒ æœªæ‰¾åˆ°ç¬¦å·: %s", oldSymbol)
		}

		var buf bytes.Buffer
		if err := printer.Fprint(&buf, fset, node); err != nil {
			return fmt.Sprintf("âŒ ç”Ÿæˆä»£ç å¤±è´¥: %v", err)
		}

		newContent = buf.Bytes()
		result = fmt.Sprintf("âœ… Goæ™ºèƒ½é‡å‘½å: %s â†’ %s (å…±%då¤„ï¼Œç­‰å¾…æ‰¹å‡†)", oldSymbol, newSymbol, changeCount)
	} else {
		// å…¶ä»–æ–‡ä»¶ç”¨æ­£åˆ™
		text := string(oldContent)
		pattern := `\b` + regexp.QuoteMeta(oldSymbol) + `\b`
		re := regexp.MustCompile(pattern)

		matches := re.FindAllStringIndex(text, -1)
		if len(matches) == 0 {
			return fmt.Sprintf("âŒ æœªæ‰¾åˆ°ç¬¦å·: %s", oldSymbol)
		}

		newText := re.ReplaceAllString(text, newSymbol)
		newContent = []byte(newText)
		result = fmt.Sprintf("âœ… é€šç”¨æ™ºèƒ½é‡å‘½å: %s â†’ %s (å…±%då¤„ï¼Œç­‰å¾…æ‰¹å‡†)", oldSymbol, newSymbol, len(matches))
	}

	// å†™å…¥æ–°å†…å®¹
	if err := os.WriteFile(file, newContent, 0644); err != nil {
		return fmt.Sprintf("âŒ å†™å…¥æ–‡ä»¶å¤±è´¥: %v", err)
	}

	// ä¿å­˜å¤‡ä»½ï¼ˆåŒä¸€æ–‡ä»¶åªä¿ç•™ç¬¬ä¸€æ¬¡å¤‡ä»½ï¼‰
	backupMutex.Lock()
	hasBackup := false
	for _, b := range backups {
		if b.FilePath == file {
			hasBackup = true
			break
		}
	}
	if !hasBackup {
		backups = append(backups, OperationBackup{
			ToolCallID: toolCallID,
			Type:       "rename",
			FilePath:   file,
			OldContent: oldContent,
			EditCount:  1,
		})
	} else {
		for i := range backups {
			if backups[i].FilePath == file {
				backups[i].EditCount++
				backups[i].Type = "rename" // æ›´æ–°ä¸ºrename
				break
			}
		}
	}
	backupMutex.Unlock()

	return result
}

func executeDeleteFile(toolCallID string, args map[string]interface{}) string {
	file := args["file"].(string)

	// å¤‡ä»½åŸæ–‡ä»¶
	oldContent, err := os.ReadFile(file)
	if err != nil {
		return fmt.Sprintf("âŒ è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
	}

	// åˆ é™¤æ–‡ä»¶
	if err := os.Remove(file); err != nil {
		return fmt.Sprintf("âŒ åˆ é™¤å¤±è´¥: %v", err)
	}

	// ä¿å­˜å¤‡ä»½
	backupMutex.Lock()
	backups = append(backups, OperationBackup{
		ToolCallID: toolCallID,
		Type:       "delete",
		FilePath:   file,
		OldContent: oldContent,
		EditCount:  1,
	})
	backupMutex.Unlock()

	return fmt.Sprintf("âœ… æ–‡ä»¶å·²åˆ é™¤: %sï¼ˆç­‰å¾…ç”¨æˆ·æ‰¹å‡†ï¼‰", file)
}

func executeRunCommand(args map[string]interface{}) string {
	command := args["command"].(string)
	interactive := args["interactive"].(bool)

	if interactive {
		processID, err := processManager.StartProcess(command)
		if err != nil {
			return fmt.Sprintf("âŒ å¯åŠ¨å¤±è´¥: %v", err)
		}
		return fmt.Sprintf("âœ… è¿›ç¨‹å·²å¯åŠ¨\nè¿›ç¨‹ID: %s\nå‘½ä»¤: %s", processID, command)
	}

	cmd := exec.Command("bash", "-c", command)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Sprintf("%s\n[è¿”å›ç : %d]", string(output), cmd.ProcessState.ExitCode())
	}
	return fmt.Sprintf("%s\n[è¿”å›ç : 0]", string(output))
}

func executeSendInput(args map[string]interface{}) string {
	processID := args["process_id"].(string)
	input := args["input"].(string)

	if err := processManager.SendInput(processID, input); err != nil {
		return fmt.Sprintf("âŒ %v", err)
	}

	time.Sleep(300 * time.Millisecond)

	output, status, err := processManager.GetOutput(processID)
	if err != nil {
		return fmt.Sprintf("âŒ %v", err)
	}

	if output != "" {
		return fmt.Sprintf("ğŸ“¤ è¿›ç¨‹å“åº”:\n```\n%s```\nçŠ¶æ€: %s", output, status)
	}
	return fmt.Sprintf("âœ… è¾“å…¥å·²å‘é€ï¼ˆæš‚æ— è¾“å‡ºï¼‰\nçŠ¶æ€: %s", status)
}

func executeGetOutput(args map[string]interface{}) string {
	processID := args["process_id"].(string)

	output, status, err := processManager.GetOutput(processID)
	if err != nil {
		return fmt.Sprintf("âŒ %v", err)
	}

	if output == "" {
		return fmt.Sprintf("â„¹ï¸  æš‚æ— è¾“å‡º\nçŠ¶æ€: %s", status)
	}
	return fmt.Sprintf("ğŸ“¤ è¿›ç¨‹è¾“å‡º:\n```\n%s```\nçŠ¶æ€: %s", output, status)
}

func executeKillProcess(args map[string]interface{}) string {
	processID := args["process_id"].(string)

	if err := processManager.KillProcess(processID); err != nil {
		return fmt.Sprintf("âŒ %v", err)
	}
	return fmt.Sprintf("âœ… è¿›ç¨‹å·²ç»ˆæ­¢: %s", processID)
}

// ==================== ä»£ç æœç´¢å·¥å…· ====================

func executeSearchCode(args map[string]interface{}) string {
	query := args["query"].(string)
	path := "."
	if p, ok := args["path"].(string); ok && p != "" {
		path = p
	}

	// æ„å»ºgrepå‘½ä»¤
	grepArgs := []string{"-rn", query, path}

	// æ·»åŠ æ–‡ä»¶è¿‡æ»¤
	if pattern, ok := args["file_pattern"].(string); ok && pattern != "" {
		grepArgs = append(grepArgs, "--include="+pattern)
	}

	// æ­£åˆ™æ¨¡å¼
	if isRegex, ok := args["is_regex"].(bool); ok && isRegex {
		grepArgs = append(grepArgs, "-E")
	}

	cmd := exec.Command("grep", grepArgs...)
	output, err := cmd.CombinedOutput()

	if err != nil && len(output) == 0 {
		return fmt.Sprintf("âŒ æœªæ‰¾åˆ°åŒ¹é…: %s", query)
	}

	// è§£æç»“æœï¼Œé™åˆ¶è¡Œæ•°
	lines := strings.Split(string(output), "\n")
	if len(lines) > 50 {
		lines = lines[:50]
		return fmt.Sprintf("ğŸ” æœç´¢ç»“æœï¼ˆå‰50æ¡ï¼‰:\n```\n%s```\n... è¿˜æœ‰æ›´å¤šç»“æœ", strings.Join(lines, "\n"))
	}

	return fmt.Sprintf("ğŸ” æœç´¢ç»“æœ:\n```\n%s```", string(output))
}

func executeFindSymbol(args map[string]interface{}) string {
	symbol := args["symbol"].(string)
	symbolType := ""
	if st, ok := args["symbol_type"].(string); ok {
		symbolType = st
	}

	var patterns []string
	switch symbolType {
	case "function":
		patterns = []string{fmt.Sprintf("func.*%s", symbol), fmt.Sprintf("def %s", symbol)}
	case "type":
		patterns = []string{fmt.Sprintf("type %s", symbol), fmt.Sprintf("class %s", symbol)}
	case "var":
		patterns = []string{fmt.Sprintf("var %s", symbol), fmt.Sprintf("%s :?=", symbol)}
	case "const":
		patterns = []string{fmt.Sprintf("const %s", symbol)}
	default:
		// æœç´¢æ‰€æœ‰ç±»å‹
		patterns = []string{
			fmt.Sprintf("func.*%s", symbol),
			fmt.Sprintf("type %s", symbol),
			fmt.Sprintf("class %s", symbol),
			fmt.Sprintf("def %s", symbol),
		}
	}

	var allResults []string
	for _, pattern := range patterns {
		cmd := exec.Command("grep", "-rn", "-E", pattern, ".")
		output, _ := cmd.CombinedOutput()
		if len(output) > 0 {
			allResults = append(allResults, string(output))
		}
	}

	if len(allResults) == 0 {
		return fmt.Sprintf("âŒ æœªæ‰¾åˆ°ç¬¦å·å®šä¹‰: %s", symbol)
	}

	combined := strings.Join(allResults, "")
	lines := strings.Split(combined, "\n")
	if len(lines) > 20 {
		lines = lines[:20]
	}

	return fmt.Sprintf("ğŸ” æ‰¾åˆ°ç¬¦å· '%s' çš„å®šä¹‰:\n```\n%s```", symbol, strings.Join(lines, "\n"))
}

// ==================== é¡¹ç›®åˆ†æå·¥å…· ====================

func executeListDirectory(args map[string]interface{}) string {
	path := "."
	if p, ok := args["path"].(string); ok && p != "" {
		path = p
	}

	recursive := false
	if r, ok := args["recursive"].(bool); ok {
		recursive = r
	}

	pattern := ""
	if p, ok := args["pattern"].(string); ok {
		pattern = p
	}

	var files []string
	var totalSize int64

	walkFn := func(p string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		// è·³è¿‡éšè—ç›®å½•
		if info.IsDir() && strings.HasPrefix(info.Name(), ".") && p != path {
			return nil
		}

		// å¦‚æœä¸é€’å½’ï¼Œè·³è¿‡å­ç›®å½•
		if !recursive && info.IsDir() && p != path {
			return nil
		}

		// è¿‡æ»¤æ–‡ä»¶
		if !info.IsDir() {
			if pattern != "" {
				matched, _ := regexp.MatchString(strings.ReplaceAll(pattern, "*", ".*"), info.Name())
				if !matched {
					return nil
				}
			}

			relPath := strings.TrimPrefix(p, path+"/")
			if relPath == p {
				relPath = info.Name()
			}

			files = append(files, fmt.Sprintf("%s (%d lines, %s)",
				relPath,
				countLines(p),
				formatSize(info.Size())))
			totalSize += info.Size()
		}

		return nil
	}

	if err := filepath.Walk(path, walkFn); err != nil {
		return fmt.Sprintf("âŒ åˆ—å‡ºç›®å½•å¤±è´¥: %v", err)
	}

	if len(files) == 0 {
		return fmt.Sprintf("â„¹ï¸  ç›®å½•ä¸ºç©ºæˆ–æ— åŒ¹é…æ–‡ä»¶: %s", path)
	}

	// é™åˆ¶è¾“å‡º
	if len(files) > 100 {
		files = files[:100]
		return fmt.Sprintf("ğŸ“ ç›®å½•åˆ—è¡¨ï¼ˆå‰100ä¸ªï¼‰:\n%s\n\næ€»è®¡: %s, ... è¿˜æœ‰æ›´å¤š",
			strings.Join(files, "\n"),
			formatSize(totalSize))
	}

	return fmt.Sprintf("ğŸ“ ç›®å½•åˆ—è¡¨:\n%s\n\næ€»è®¡: %d ä¸ªæ–‡ä»¶, %s",
		strings.Join(files, "\n"),
		len(files),
		formatSize(totalSize))
}

func executeGetProjectStructure(args map[string]interface{}) string {
	maxDepth := 3
	if md, ok := args["max_depth"].(float64); ok {
		maxDepth = int(md)
	}

	var result strings.Builder
	result.WriteString("ğŸ“¦ é¡¹ç›®ç»“æ„:\n```\n")

	var walk func(path string, depth int, prefix string)
	walk = func(path string, depth int, prefix string) {
		if depth > maxDepth {
			return
		}

		entries, err := os.ReadDir(path)
		if err != nil {
			return
		}

		for i, entry := range entries {
			// è·³è¿‡éšè—æ–‡ä»¶å’Œå¸¸è§å¿½ç•¥ç›®å½•
			if strings.HasPrefix(entry.Name(), ".") ||
				entry.Name() == "node_modules" ||
				entry.Name() == "vendor" {
				continue
			}

			isLast := i == len(entries)-1
			connector := "â”œâ”€â”€ "
			if isLast {
				connector = "â””â”€â”€ "
			}

			result.WriteString(prefix + connector + entry.Name())

			if entry.IsDir() {
				result.WriteString("/\n")
				newPrefix := prefix
				if isLast {
					newPrefix += "    "
				} else {
					newPrefix += "â”‚   "
				}
				walk(path+"/"+entry.Name(), depth+1, newPrefix)
			} else {
				result.WriteString("\n")
			}
		}
	}

	walk(".", 0, "")
	result.WriteString("```")

	return result.String()
}

func executeGetFileStats(args map[string]interface{}) string {
	file := args["file"].(string)

	info, err := os.Stat(file)
	if err != nil {
		return fmt.Sprintf("âŒ è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v", err)
	}

	lineCount := countLines(file)

	return fmt.Sprintf("ğŸ“Š æ–‡ä»¶ç»Ÿè®¡: %s\n"+
		"- å¤§å°: %s\n"+
		"- è¡Œæ•°: %d\n"+
		"- ä¿®æ”¹æ—¶é—´: %s",
		file,
		formatSize(info.Size()),
		lineCount,
		info.ModTime().Format("2006-01-02 15:04:05"))
}

// ==================== Gitå·¥å…· ====================

func executeGitStatus(args map[string]interface{}) string {
	cmd := exec.Command("git", "status", "--short")
	output, err := cmd.CombinedOutput()

	if err != nil {
		return fmt.Sprintf("âŒ Gité”™è¯¯: %v\n%s", err, string(output))
	}

	if len(output) == 0 {
		return "âœ… å·¥ä½œç›®å½•å¹²å‡€ï¼Œæ²¡æœ‰ä¿®æ”¹"
	}

	return fmt.Sprintf("ğŸ“ GitçŠ¶æ€:\n```\n%s```", string(output))
}

func executeGitDiff(args map[string]interface{}) string {
	var cmd *exec.Cmd
	if file, ok := args["file"].(string); ok && file != "" {
		cmd = exec.Command("git", "diff", file)
	} else {
		cmd = exec.Command("git", "diff")
	}

	output, err := cmd.CombinedOutput()

	if err != nil {
		return fmt.Sprintf("âŒ Gité”™è¯¯: %v", err)
	}

	if len(output) == 0 {
		return "â„¹ï¸  æ²¡æœ‰å·®å¼‚"
	}

	// é™åˆ¶è¾“å‡ºé•¿åº¦
	if len(output) > 5000 {
		output = output[:5000]
		return fmt.Sprintf("ğŸ“ Gitå·®å¼‚ï¼ˆå‰5000å­—ç¬¦ï¼‰:\n```diff\n%s```\n... è¾“å‡ºè¢«æˆªæ–­", string(output))
	}

	return fmt.Sprintf("ğŸ“ Gitå·®å¼‚:\n```diff\n%s```", string(output))
}

func executeGitCommit(args map[string]interface{}) string {
	message := args["message"].(string)

	var files []string
	if f, ok := args["files"].([]interface{}); ok {
		for _, file := range f {
			if fileStr, ok := file.(string); ok {
				files = append(files, fileStr)
			}
		}
	}

	// æ·»åŠ æ–‡ä»¶
	if len(files) > 0 {
		for _, file := range files {
			cmd := exec.Command("git", "add", file)
			if output, err := cmd.CombinedOutput(); err != nil {
				return fmt.Sprintf("âŒ Git addå¤±è´¥: %v\n%s", err, string(output))
			}
		}
	} else {
		// æ·»åŠ æ‰€æœ‰ä¿®æ”¹
		cmd := exec.Command("git", "add", "-A")
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Sprintf("âŒ Git addå¤±è´¥: %v\n%s", err, string(output))
		}
	}

	// æäº¤
	cmd := exec.Command("git", "commit", "-m", message)
	output, err := cmd.CombinedOutput()

	if err != nil {
		return fmt.Sprintf("âŒ Git commitå¤±è´¥: %v\n%s", err, string(output))
	}

	return fmt.Sprintf("âœ… Gitæäº¤æˆåŠŸ:\n```\n%s```", string(output))
}

// ==================== è¾…åŠ©å‡½æ•° ====================

func countLines(file string) int {
	content, err := os.ReadFile(file)
	if err != nil {
		return 0
	}
	return strings.Count(string(content), "\n") + 1
}

func formatSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

// ==================== æ’¤é”€æ“ä½œ ====================

func undoOperation(toolCallID string) error {
	backupMutex.Lock()
	defer backupMutex.Unlock()

	for i, backup := range backups {
		if backup.ToolCallID == toolCallID {
			// æ¢å¤æ–‡ä»¶
			switch backup.Type {
			case "edit", "rename":
				if err := os.WriteFile(backup.FilePath, backup.OldContent, 0644); err != nil {
					return fmt.Errorf("æ¢å¤æ–‡ä»¶å¤±è´¥: %v", err)
				}
			case "delete":
				if err := os.WriteFile(backup.FilePath, backup.OldContent, 0644); err != nil {
					return fmt.Errorf("æ¢å¤æ–‡ä»¶å¤±è´¥: %v", err)
				}
			}

			// åˆ é™¤å¤‡ä»½
			backups = append(backups[:i], backups[i+1:]...)
			return nil
		}
	}

	return fmt.Errorf("æœªæ‰¾åˆ°å¤‡ä»½")
}

func commitAllOperations() {
	backupMutex.Lock()
	defer backupMutex.Unlock()
	backups = []OperationBackup{}
}

// ==================== å·¥å…·è·¯ç”± ====================

func executeTool(toolCall openai.ToolCall) string {
	var args map[string]interface{}
	json.Unmarshal([]byte(toolCall.Function.Arguments), &args)

	switch toolCall.Function.Name {
	case "read_file":
		return executeReadFile(args)
	case "edit_file":
		return executeEditFile(toolCall.ID, args)
	case "rename_symbol":
		return executeRenameSymbol(toolCall.ID, args)
	case "delete_file":
		return executeDeleteFile(toolCall.ID, args)
	case "run_command":
		return executeRunCommand(args)
	case "send_input":
		return executeSendInput(args)
	case "get_output":
		return executeGetOutput(args)
	case "kill_process":
		return executeKillProcess(args)
	// ä»£ç æœç´¢å·¥å…·
	case "search_code":
		return executeSearchCode(args)
	case "find_symbol":
		return executeFindSymbol(args)
	// é¡¹ç›®åˆ†æå·¥å…·
	case "list_directory":
		return executeListDirectory(args)
	case "get_project_structure":
		return executeGetProjectStructure(args)
	case "get_file_stats":
		return executeGetFileStats(args)
	// Gitå·¥å…·
	case "git_status":
		return executeGitStatus(args)
	case "git_diff":
		return executeGitDiff(args)
	case "git_commit":
		return executeGitCommit(args)
	default:
		return fmt.Sprintf("âŒ æœªçŸ¥å·¥å…·: %s", toolCall.Function.Name)
	}
}

func needsImmediateApproval(functionName string) bool {
	// åªæœ‰ä¸å¯æ’¤é”€çš„æ‰§è¡Œç±»æ“ä½œéœ€è¦ç«‹å³æ‰¹å‡†
	dangerousTools := []string{
		"run_command",
		"send_input",
		"kill_process",
		"git_commit", // Gitæäº¤ä¹Ÿä¸å¯æ’¤é”€
	}
	for _, tool := range dangerousTools {
		if tool == functionName {
			return true
		}
	}
	return false
}

// ==================== æ‰¹å‡†æµç¨‹ ====================

func handleApproval(toolCalls []openai.ToolCall) map[string]bool {
	// åˆ†ç±»å·¥å…·è°ƒç”¨
	var immediateApprovalOps []openai.ToolCall // éœ€è¦ç«‹å³æ‰¹å‡†çš„
	var autoApprovalOps []openai.ToolCall      // è‡ªåŠ¨æ‰¹å‡†çš„

	for _, tc := range toolCalls {
		if needsImmediateApproval(tc.Function.Name) {
			immediateApprovalOps = append(immediateApprovalOps, tc)
		} else {
			autoApprovalOps = append(autoApprovalOps, tc)
		}
	}

	approvals := make(map[string]bool)

	// æ‰€æœ‰éç«‹å³æ‰¹å‡†çš„æ“ä½œï¼šè‡ªåŠ¨æ‰¹å‡†ï¼ˆåŒ…æ‹¬æŸ¥è¯¢ã€ä¿®æ”¹ç­‰ï¼‰
	for _, tc := range autoApprovalOps {
		approvals[tc.ID] = true
	}

	// åªæœ‰å±é™©çš„æ‰§è¡Œæ“ä½œæ‰éœ€è¦ç«‹å³æ‰¹å‡†
	if len(immediateApprovalOps) > 0 {
		fmt.Println("\nâš ï¸  ä»¥ä¸‹æ“ä½œä¸å¯æ’¤é”€ï¼Œéœ€è¦ç«‹å³æ‰¹å‡†ï¼š")
		for i, tc := range immediateApprovalOps {
			var args map[string]interface{}
			json.Unmarshal([]byte(tc.Function.Arguments), &args)
			fmt.Printf("%d. %s(%v)\n", i+1, tc.Function.Name, args)
		}
		fmt.Println("\næ‰¹å‡†æ–¹å¼:")
		fmt.Println("  y       - å…¨éƒ¨åŒæ„")
		fmt.Println("  n       - å…¨éƒ¨æ‹’ç»")
		fmt.Println("  y 1,2,3 - åªåŒæ„æŒ‡å®šçš„ï¼ˆç™½åå•ï¼‰")
		fmt.Println("  n 1,3   - æ‹’ç»æŒ‡å®šçš„ï¼ˆé»‘åå•ï¼‰")
		fmt.Print("\nè¯·é€‰æ‹©: ")
		reader := bufio.NewReader(os.Stdin)
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)

		// è§£æè¾“å…¥
		parts := strings.Fields(input) // æŒ‰ç©ºæ ¼åˆ†å‰²
		if len(parts) == 0 {
			// ç©ºè¾“å…¥ï¼Œé»˜è®¤æ‹’ç»
			return approvals
		}

		action := strings.ToLower(parts[0])

		if action == "y" {
			if len(parts) == 1 {
				// åªæœ‰yï¼Œå…¨éƒ¨åŒæ„
				for _, tc := range immediateApprovalOps {
					approvals[tc.ID] = true
				}
			} else {
				// y 1,2,3 - ç™½åå•æ¨¡å¼
				indices := parseIndices(parts[1])
				for _, idx := range indices {
					if idx > 0 && idx <= len(immediateApprovalOps) {
						approvals[immediateApprovalOps[idx-1].ID] = true
					}
				}
			}
		} else if action == "n" {
			if len(parts) == 1 {
				// åªæœ‰nï¼Œå…¨éƒ¨æ‹’ç»ï¼ˆé»˜è®¤éƒ½æ˜¯falseï¼‰
			} else {
				// n 1,3 - é»‘åå•æ¨¡å¼ï¼šå…ˆå…¨éƒ¨åŒæ„ï¼Œå†æ‹’ç»æŒ‡å®šçš„
				for _, tc := range immediateApprovalOps {
					approvals[tc.ID] = true
				}
				indices := parseIndices(parts[1])
				for _, idx := range indices {
					if idx > 0 && idx <= len(immediateApprovalOps) {
						approvals[immediateApprovalOps[idx-1].ID] = false
					}
				}
			}
		}
	}

	return approvals
}

// è§£æåºå·åˆ—è¡¨ï¼š1,2,3
func parseIndices(s string) []int {
	var indices []int
	parts := strings.Split(s, ",")
	for _, p := range parts {
		var idx int
		fmt.Sscanf(strings.TrimSpace(p), "%d", &idx)
		if idx > 0 {
			indices = append(indices, idx)
		}
	}
	return indices
}

func confirmModifyOperations() {
	backupMutex.Lock()
	if len(backups) == 0 {
		backupMutex.Unlock()
		return
	}
	backupMutex.Unlock()

	fmt.Println("\nğŸ“‹ ä»¥ä¸‹ä¿®æ”¹å·²æ‰§è¡Œï¼Œè¯·ç¡®è®¤ï¼š")
	backupMutex.Lock()
	for i, backup := range backups {
		if backup.EditCount > 1 {
			fmt.Printf("%d. %s (%dæ¬¡ä¿®æ”¹)\n", i+1, backup.FilePath, backup.EditCount)
		} else {
			fmt.Printf("%d. %s\n", i+1, backup.FilePath)
		}
	}
	backupMutex.Unlock()

	fmt.Println("\næ‰¹å‡†æ–¹å¼:")
	fmt.Println("  y       - å…¨éƒ¨ç¡®è®¤")
	fmt.Println("  n       - å…¨éƒ¨æ’¤é”€")
	fmt.Println("  y 1,2,3 - åªç¡®è®¤æŒ‡å®šçš„ï¼ˆç™½åå•ï¼‰")
	fmt.Println("  n 1,3   - æ’¤é”€æŒ‡å®šçš„ï¼ˆé»‘åå•ï¼‰")
	fmt.Print("\nè¯·é€‰æ‹©: ")
	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)

	// è§£æè¾“å…¥
	parts := strings.Fields(input)
	if len(parts) == 0 {
		fmt.Println("âŒ æ— è¾“å…¥ï¼Œé»˜è®¤å…¨éƒ¨æ’¤é”€")
		backupMutex.Lock()
		for _, backup := range backups {
			undoOperation(backup.ToolCallID)
		}
		backupMutex.Unlock()
		return
	}

	action := strings.ToLower(parts[0])

	if action == "y" {
		if len(parts) == 1 {
			// y - å…¨éƒ¨ç¡®è®¤
			commitAllOperations()
			fmt.Println("âœ… æ‰€æœ‰ä¿®æ”¹å·²ç¡®è®¤")
		} else {
			// y 1,2,3 - ç™½åå•ï¼šåªç¡®è®¤æŒ‡å®šçš„
			indices := parseIndices(parts[1])
			approved := make(map[int]bool)
			for _, idx := range indices {
				if idx > 0 && idx <= len(backups) {
					approved[idx-1] = true
				}
			}

			backupMutex.Lock()
			for i := len(backups) - 1; i >= 0; i-- {
				if !approved[i] {
					undoOperation(backups[i].ToolCallID)
					fmt.Printf("âŒ å·²æ’¤é”€: %s\n", backups[i].FilePath)
				}
			}
			backupMutex.Unlock()

			commitAllOperations()
			fmt.Println("âœ… å·²ç¡®è®¤æŒ‡å®šçš„ä¿®æ”¹")
		}
	} else if action == "n" {
		if len(parts) == 1 {
			// n - å…¨éƒ¨æ’¤é”€
			backupMutex.Lock()
			for _, backup := range backups {
				undoOperation(backup.ToolCallID)
			}
			backupMutex.Unlock()
			fmt.Println("âŒ æ‰€æœ‰ä¿®æ”¹å·²æ’¤é”€")
		} else {
			// n 1,3 - é»‘åå•ï¼šåªæ’¤é”€æŒ‡å®šçš„
			indices := parseIndices(parts[1])
			rejected := make(map[int]bool)
			for _, idx := range indices {
				if idx > 0 && idx <= len(backups) {
					rejected[idx-1] = true
				}
			}

			backupMutex.Lock()
			for i, backup := range backups {
				if rejected[i] {
					undoOperation(backup.ToolCallID)
					fmt.Printf("âŒ å·²æ’¤é”€: %s\n", backup.FilePath)
				}
			}
			backupMutex.Unlock()

			commitAllOperations()
			fmt.Println("âœ… å…¶ä»–ä¿®æ”¹å·²ç¡®è®¤")
		}
	}
}

// ==================== å†å²ç®¡ç† ====================

func convertToOpenAIMessages(messages []Message) []openai.ChatCompletionMessage {
	var result []openai.ChatCompletionMessage
	for _, msg := range messages {
		result = append(result, openai.ChatCompletionMessage{
			Role:       msg.Role,
			Content:    msg.Content,
			ToolCalls:  msg.ToolCalls,
			ToolCallID: msg.ToolCallID,
		})
	}
	return result
}

// ==================== ç¯å¢ƒæ£€æµ‹ ====================

type SystemEnvironment struct {
	OS            string
	PythonCommand string
	HasGrep       bool
	HasTree       bool
	HasGit        bool
	Shell         string
}

func detectEnvironment() SystemEnvironment {
	env := SystemEnvironment{
		OS: runtime.GOOS,
	}

	// æ£€æµ‹Shell
	if runtime.GOOS == "windows" {
		env.Shell = "powershell"
	} else {
		env.Shell = "bash"
	}

	// æ£€æµ‹Pythonå‘½ä»¤
	if _, err := exec.Command("python3", "--version").CombinedOutput(); err == nil {
		env.PythonCommand = "python3"
	} else if _, err := exec.Command("python", "--version").CombinedOutput(); err == nil {
		env.PythonCommand = "python"
	} else {
		env.PythonCommand = "none"
	}

	// æ£€æµ‹grep
	if runtime.GOOS == "windows" {
		env.HasGrep = false // Windowsé»˜è®¤ç”¨findstr
	} else {
		_, err := exec.Command("which", "grep").CombinedOutput()
		env.HasGrep = err == nil
	}

	// æ£€æµ‹tree
	_, err := exec.Command("which", "tree").CombinedOutput()
	if runtime.GOOS == "windows" {
		_, err = exec.Command("where", "tree").CombinedOutput()
	}
	env.HasTree = err == nil

	// æ£€æµ‹git
	_, err = exec.Command("git", "--version").CombinedOutput()
	env.HasGit = err == nil

	return env
}

func buildSystemPrompt(env SystemEnvironment) string {
	var prompt strings.Builder

	prompt.WriteString("ä½ æ˜¯ä¸€ä¸ªå¼ºå¤§çš„AIç¼–ç¨‹åŠ©æ‰‹ï¼Œå¯ä»¥é€šè¿‡Function Callingè°ƒç”¨å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·ã€‚\n\n")

	prompt.WriteString("## å½“å‰ç³»ç»Ÿç¯å¢ƒ (ç³»ç»Ÿè‡ªæ£€)\n\n")
	prompt.WriteString("ä»¥ä¸‹æ˜¯ç¨‹åºå¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹çš„ç³»ç»Ÿä¿¡æ¯ï¼Œè¿™äº›æ˜¯äº‹å®ï¼Œè¯·æ ¹æ®è¿™äº›ä¿¡æ¯è°ƒæ•´ä½ çš„å‘½ä»¤å’Œå»ºè®®ï¼š\n\n")

	prompt.WriteString(fmt.Sprintf("**æ“ä½œç³»ç»Ÿ** (è‡ªæ£€): %s\n", env.OS))
	prompt.WriteString(fmt.Sprintf("**Shell** (è‡ªæ£€): %s\n", env.Shell))

	if env.PythonCommand != "none" {
		prompt.WriteString(fmt.Sprintf("**Pythonå‘½ä»¤** (è‡ªæ£€): %s âœ… å·²å®‰è£…ï¼Œè¿è¡ŒPythonè„šæœ¬æ—¶å¿…é¡»ä½¿ç”¨æ­¤å‘½ä»¤\n", env.PythonCommand))
	} else {
		prompt.WriteString("**Python** (è‡ªæ£€): âŒ æœªå®‰è£…ï¼Œæ— æ³•è¿è¡ŒPythonè„šæœ¬\n")
	}

	if env.HasGit {
		prompt.WriteString("**Git** (è‡ªæ£€): âœ… å¯ç”¨\n")
	} else {
		prompt.WriteString("**Git** (è‡ªæ£€): âŒ æœªå®‰è£…ï¼Œä¸è¦ä½¿ç”¨gitå‘½ä»¤\n")
	}

	prompt.WriteString("\n## å‘½ä»¤ä½¿ç”¨æŒ‡å— (æ ¹æ®ç³»ç»Ÿè‡ªæ£€ç»“æœ)\n\n")

	if env.OS == "windows" {
		prompt.WriteString("### å½“å‰æ˜¯Windowsç³»ç»Ÿï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š\n")
		prompt.WriteString("- åˆ—å‡ºæ–‡ä»¶: `dir` æˆ– `Get-ChildItem` (ä¸è¦ç”¨ls)\n")
		prompt.WriteString("- æœç´¢æ–‡æœ¬: `findstr` (ä¸è¦ç”¨grepï¼ŒWindowsæ²¡æœ‰grep)\n")
		prompt.WriteString("- æŸ¥çœ‹æ–‡ä»¶: `type` (ä¸è¦ç”¨cat)\n")
		prompt.WriteString("- åˆ é™¤æ–‡ä»¶: `del` æˆ– `Remove-Item` (ä¸è¦ç”¨rm)\n")
		prompt.WriteString("- å¤åˆ¶æ–‡ä»¶: `copy` æˆ– `Copy-Item` (ä¸è¦ç”¨cp)\n")
		prompt.WriteString("- è·¯å¾„åˆ†éš”ç¬¦: ä½¿ç”¨ `\\` è€Œä¸æ˜¯ `/`\n")
		prompt.WriteString("- æ¸…å±: `cls` (ä¸è¦ç”¨clear)\n")
	} else {
		prompt.WriteString("### å½“å‰æ˜¯Unix/Linuxç³»ç»Ÿï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š\n")
		prompt.WriteString("- åˆ—å‡ºæ–‡ä»¶: `ls` (ä¸è¦ç”¨dir)\n")
		if env.HasGrep {
			prompt.WriteString("- æœç´¢æ–‡æœ¬: `grep` âœ… å·²å®‰è£…ï¼Œå¯ä»¥ä½¿ç”¨\n")
		} else {
			prompt.WriteString("- æœç´¢æ–‡æœ¬: `grep` âŒ æœªå®‰è£…ï¼Œè¯·ä½¿ç”¨search_codeå·¥å…·ä»£æ›¿\n")
		}
		prompt.WriteString("- æŸ¥çœ‹æ–‡ä»¶: `cat` (ä¸è¦ç”¨type)\n")
		prompt.WriteString("- åˆ é™¤æ–‡ä»¶: `rm` (ä¸è¦ç”¨del)\n")
		prompt.WriteString("- å¤åˆ¶æ–‡ä»¶: `cp` (ä¸è¦ç”¨copy)\n")
		prompt.WriteString("- è·¯å¾„åˆ†éš”ç¬¦: ä½¿ç”¨ `/` è€Œä¸æ˜¯ `\\`\n")
		prompt.WriteString("- æ¸…å±: `clear` (ä¸è¦ç”¨cls)\n")
	}

	if env.PythonCommand != "none" {
		prompt.WriteString(fmt.Sprintf("\n**Pythonè„šæœ¬æ‰§è¡Œæ–¹å¼ (ç³»ç»Ÿè‡ªæ£€)**: å¿…é¡»ä½¿ç”¨ `%s script.py`ï¼Œä¸è¦ä½¿ç”¨å…¶ä»–Pythonå‘½ä»¤\n", env.PythonCommand))
	} else {
		prompt.WriteString("\n**Python (ç³»ç»Ÿè‡ªæ£€)**: ç³»ç»Ÿæœªå®‰è£…Pythonï¼Œå¦‚æœç”¨æˆ·è¦æ±‚è¿è¡ŒPythonè„šæœ¬ï¼Œè¯·å‘ŠçŸ¥ç”¨æˆ·éœ€è¦å…ˆå®‰è£…Python\n")
	}

	prompt.WriteString("\n## å·¥å…·ä½¿ç”¨å»ºè®®\n\n")
	prompt.WriteString("1. **æœç´¢ä»£ç **: ä¼˜å…ˆä½¿ç”¨ `search_code` å·¥å…·ï¼ˆè·¨å¹³å°ï¼Œè‡ªåŠ¨é€‚é…ï¼‰\n")
	prompt.WriteString("2. **æŸ¥çœ‹ç›®å½•**: ä¼˜å…ˆä½¿ç”¨ `list_directory` å·¥å…·ï¼ˆè·¨å¹³å°ï¼Œè‡ªåŠ¨é€‚é…ï¼‰\n")
	prompt.WriteString("3. **Gitæ“ä½œ**: ")
	if env.HasGit {
		prompt.WriteString("ä¼˜å…ˆä½¿ç”¨ `git_*` å·¥å…·ï¼Œæˆ–ä½¿ç”¨run_commandè°ƒç”¨gitå‘½ä»¤\n")
	} else {
		prompt.WriteString("âŒ Gitæœªå®‰è£…ï¼Œä¸è¦å°è¯•ä½¿ç”¨ä»»ä½•gitå‘½ä»¤\n")
	}
	prompt.WriteString("4. **è¿è¡Œå‘½ä»¤**: ä½¿ç”¨ `run_command` æ—¶ï¼Œå¿…é¡»ä½¿ç”¨ä¸Šè¿°ç³»ç»Ÿå¯¹åº”çš„å‘½ä»¤ï¼Œä¸è¦ä½¿ç”¨é”™è¯¯çš„å‘½ä»¤\n")

	prompt.WriteString("\n**é‡è¦**: ä¸Šè¿°ç¯å¢ƒä¿¡æ¯æ˜¯ç¨‹åºè‡ªåŠ¨æ£€æµ‹çš„çœŸå®ç³»ç»ŸçŠ¶æ€ï¼Œä¸æ˜¯å‡è®¾ã€‚è¯·ä¸¥æ ¼éµå®ˆè¿™äº›çº¦æŸã€‚\n")

	return prompt.String()
}

func loadHistory() []Message {
	// æ£€æµ‹ç¯å¢ƒ
	env := detectEnvironment()
	systemPrompt := buildSystemPrompt(env)

	data, err := os.ReadFile(HistoryFile)
	if err != nil {
		return []Message{{Role: "system", Content: systemPrompt}}
	}

	var messages []Message
	if err := json.Unmarshal(data, &messages); err != nil {
		return []Message{{Role: "system", Content: systemPrompt}}
	}

	if len(messages) == 0 {
		return []Message{{Role: "system", Content: systemPrompt}}
	}

	// æ›´æ–°system promptä¸ºå½“å‰ç¯å¢ƒ
	if len(messages) > 0 && messages[0].Role == "system" {
		messages[0].Content = systemPrompt
	}

	return messages
}

func saveHistory(messages []Message) error {
	data, err := json.MarshalIndent(messages, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(HistoryFile, data, 0644)
}

// ==================== ä¸»ç¨‹åº ====================

func main() {
	// æ£€æµ‹ç¯å¢ƒ
	env := detectEnvironment()

	fmt.Println("=" + strings.Repeat("=", 59))
	fmt.Println("ğŸ¤– AIç¼–ç¨‹åŠ©æ‰‹ - Function Callingç‰ˆæœ¬")
	fmt.Println("=" + strings.Repeat("=", 59))

	// æ˜¾ç¤ºç¯å¢ƒä¿¡æ¯
	fmt.Println("ğŸ“‹ ç³»ç»Ÿç¯å¢ƒï¼š")
	fmt.Printf("  - æ“ä½œç³»ç»Ÿ: %s\n", env.OS)
	fmt.Printf("  - Shell: %s\n", env.Shell)
	if env.PythonCommand != "none" {
		fmt.Printf("  - Python: %s âœ…\n", env.PythonCommand)
	} else {
		fmt.Printf("  - Python: æœªå®‰è£… âŒ\n")
	}
	if env.HasGit {
		fmt.Printf("  - Git: å¯ç”¨ âœ…\n")
	} else {
		fmt.Printf("  - Git: æœªå®‰è£… âŒ\n")
	}

	fmt.Println("=" + strings.Repeat("=", 59))
	fmt.Println("ç‰¹æ€§ï¼š")
	fmt.Println("  - æŸ¥è¯¢æ“ä½œï¼ˆread, get_outputï¼‰ï¼šè‡ªåŠ¨æ‰§è¡Œ")
	fmt.Println("  - ä¿®æ”¹æ“ä½œï¼ˆedit, rename, deleteï¼‰ï¼šå…ˆæ‰§è¡Œï¼Œåç¡®è®¤ï¼Œå¯æ’¤é”€")
	fmt.Println("  - æ‰§è¡Œæ“ä½œï¼ˆrun, send, killï¼‰ï¼šæå‰è¯¢é—®ï¼Œæ‰¹å‡†åæ‰§è¡Œ")
	fmt.Println("=" + strings.Repeat("=", 59))

	config := openai.DefaultConfig(APIKey)
	config.BaseURL = BaseURL
	client := openai.NewClientWithConfig(config)

	messages := loadHistory()
	fmt.Printf("ğŸ“š å·²åŠ è½½ %d æ¡å†å²æ¶ˆæ¯\n\n", len(messages)-1)

	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Print("\nğŸ‘¤ ä½ : ")
		userInput, _ := reader.ReadString('\n')
		userInput = strings.TrimSpace(userInput)

		if userInput == "" {
			continue
		}

		if userInput == "quit" || userInput == "exit" || userInput == "q" {
			fmt.Println("\nğŸ‘‹ å†è§ï¼")
			break
		}

		messages = append(messages, Message{Role: "user", Content: userInput})

		// è°ƒç”¨APIï¼ˆæµå¼ï¼‰
		for {
			stream, err := client.CreateChatCompletionStream(context.Background(), openai.ChatCompletionRequest{
				Model:    Model,
				Messages: convertToOpenAIMessages(messages),
				Tools:    getTools(),
			})

			if err != nil {
				fmt.Printf("\nâŒ APIé”™è¯¯: %v\n", err)
				break
			}
			defer stream.Close()

			// æ”¶é›†æµå¼å“åº”
			var fullContent strings.Builder
			var toolCalls []openai.ToolCall
			var displayedContent bool

			fmt.Print("\nğŸ¤– AI: ")

			for {
				response, err := stream.Recv()
				if err == io.EOF {
					break
				}
				if err != nil {
					fmt.Printf("\nâŒ æµå¼é”™è¯¯: %v\n", err)
					break
				}

				delta := response.Choices[0].Delta

				// æµå¼æ˜¾ç¤ºå†…å®¹
				if delta.Content != "" {
					if !displayedContent {
						displayedContent = true
					}
					fmt.Print(delta.Content)
					fullContent.WriteString(delta.Content)
				}

				// æ”¶é›†tool_callsï¼ˆåœ¨æœ€åçš„chunkä¸­ï¼‰
				if len(delta.ToolCalls) > 0 {
					for _, tc := range delta.ToolCalls {
						// å¦‚æœæ˜¯æ–°çš„tool call
						if tc.Index != nil && *tc.Index >= len(toolCalls) {
							toolCalls = append(toolCalls, openai.ToolCall{
								ID:   tc.ID,
								Type: tc.Type,
								Function: openai.FunctionCall{
									Name:      tc.Function.Name,
									Arguments: tc.Function.Arguments,
								},
							})
						} else if tc.Index != nil {
							// ç´¯åŠ arguments
							idx := *tc.Index
							toolCalls[idx].Function.Arguments += tc.Function.Arguments
						}
					}
				}
			}

			if displayedContent {
				fmt.Println() // æ¢è¡Œ
			}

			// ä¿å­˜AIæ¶ˆæ¯
			messages = append(messages, Message{
				Role:      "assistant",
				Content:   fullContent.String(),
				ToolCalls: toolCalls,
			})
			saveHistory(messages)

			// å¤„ç†å·¥å…·è°ƒç”¨
			if len(toolCalls) == 0 {
				break
			}

			// æ‰¹å‡†æµç¨‹
			approvals := handleApproval(toolCalls)

			// æ‰§è¡Œå·¥å…·
			for _, toolCall := range toolCalls {
				var result string
				if approved, exists := approvals[toolCall.ID]; exists && approved {
					result = executeTool(toolCall)
					fmt.Printf("\nğŸ”§ %s: %s\n", toolCall.Function.Name, result)
				} else {
					result = "âŒ ç”¨æˆ·æ‹’ç»æ‰§è¡Œæ­¤æ“ä½œ"
					fmt.Printf("\nğŸ”§ %s: %s\n", toolCall.Function.Name, result)
				}

				messages = append(messages, Message{
					Role:       "tool",
					Content:    result,
					ToolCallID: toolCall.ID,
				})
			}

			saveHistory(messages)
		}

		// AIå›å¤å®Œæˆåï¼Œç¡®è®¤ä¿®æ”¹æ“ä½œ
		confirmModifyOperations()
	}
}
